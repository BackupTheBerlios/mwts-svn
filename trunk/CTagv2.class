' Gambas class file

PUBLIC CONST trackNone AS Integer = 0

PROPERTY artist AS String[] 
PROPERTY album AS String[]
PROPERTY track AS String[]
PROPERTY year AS String[]
PROPERTY genre AS String[]
PROPERTY title AS String[]
PROPERTY comment AS String

PROPERTY READ isEmpty AS Boolean ' returns whether a new and empty tag was created or has already been changed
PROPERTY version AS Float ' the version of this ID3-Tag; currently only 2.4 is handled
PROPERTY READ changed AS Boolean ' returns whether the tag has been changed since creation
PROPERTY READ header AS CTagv2Header ' the header of this tag
PROPERTY READ extHeader AS CTagv2ExtHeader ' the extended header of this tag; might be NULL
PROPERTY READ statusOK AS Boolean ' returns whether the tag has been parsed completely without any errors
PROPERTY READ parent AS CTag ' needed for dynamic reload of content by some frames containing binary data

PRIVATE $changed AS Boolean
PRIVATE $status AS Boolean
PRIVATE $version AS String
PRIVATE $header AS CTagv2Header
PRIVATE $extHeader AS CTagv2ExtHeader
PRIVATE $body AS String ' contains all frames and the optional padding
PRIVATE $frames AS Collection ' contains all frames
PRIVATE $parent AS CTag

PUBLIC SUB _new(parent AS CTag, OPTIONAL path AS String = NULL)
  
  DIM s AS String
  DIM x AS Integer
  DIM y AS Integer
  DIM f AS File
  DIM bsize AS Integer
  DIM z AS Long = -1
  
  DIM begin AS Integer
  DIM size AS Integer
  
  'RETURN 
  
  $parent = parent
  
  IF IsNull(path) OR NOT Exist(path) THEN 
    die
    RETURN 
  END IF
  
  f = OPEN path FOR INPUT 
  'begin = MHelp.fseek(path, MHelp.str2pat("ID3")) 
  'begin = MHelp.fseekf(path, "ID3")
  IF begin = -1 THEN RETURN 
  
  SEEK #f, begin
  TRY READ #f, s, 10
  IF ERROR THEN 
    die
    RETURN 
  END IF
  $header = NEW CTagv2Header(s, begin)
  IF NOT $header.statusOK THEN 
    die
    RETURN 
  END IF
  $version = $header.version
  IF $header.useExtHeader THEN 
    READ #f, s, 4
    SEEK #f, begin + $header.size
    READ #f, s, DeSynchsafe(s)
    $extHeader = NEW CTagv2ExtHeader(s, begin + $header.size)
    y = $extHeader.size
  END IF
  
  z = $header.tagSize
  bsize = z - y - CInt(If($header.useFooter, 10, 0))
  
  TRY READ #f, $body, bsize
  CLOSE #f
  
  IF z > -1 OR ERROR THEN ' no error during parsing of synchsafe integers
    $frames = getFrames($body)
    $status = TRUE
  ELSE 
    die
  END IF
  
END

PRIVATE SUB die()
  
  $header = NEW CTagv2Header
  $extHeader = NEW CTagv2ExtHeader
  $frames = NEW Collection(gb.Text)
  $status = FALSE
  RETURN 
  
END

PUBLIC SUB _free()
  FOR EACH $frames
    $frames[$frames.Key] = NULL
  NEXT 
END

PUBLIC FUNCTION _get(id AS String) AS Object
  IF $frames.Exist(id) THEN RETURN $frames[id]
  ' create new one and add it to $frames
  RETURN NULL
END


PUBLIC FUNCTION getFrames(OPTIONAL body AS String = NULL) AS Collection
  
  DIM result AS NEW Collection(gb.Text)
  DIM h AS CTagv2FrameHeader
  DIM f AS CTagv2Frame
  DIM fbody AS String
  DIM x AS Integer
  
  IF IsNull(body) THEN body = $body
  
  DO
    IF Left(body) = Chr(0) THEN BREAK 
    h = NEW CTagv2FrameHeader(Left(body, 10), x)
    fbody = Mid(body, h.size + 1, h.frameSize)
    x += h.size
    
    f = NULL
    IF h.id = "TXXX" THEN ' user-defined text-frame
      f = NEW CTagv2FrameText(NULL, ME, h)
    ELSE IF h.id = "WXXX" THEN ' user-defined url-frame
      f = NEW CTagv2FrameURL(NULL, ME, h)
    ELSE 
      IF Left(h.id) = "T" THEN ' text-frame
        f = NEW CTagv2FrameText(fbody, ME, h)
      ELSE IF Left(h.id) = "W" THEN ' url-frame
        f = NEW CTagv2FrameURL(fbody, ME, h)
      ELSE 
        SELECT CASE h.id
          CASE "APIC"
            f = NEW ID3APIC(fbody, NULL, ME, h)
          CASE "COMM"
            f = NEW ID3COMM(fbody, ME, h)
          CASE "ETCO"
            f = NEW ID3ETCO(fbody, ME, h)
          CASE "GEOB"
            f = NEW ID3GEOB(fbody, NULL, ME, h)
          CASE "MCDI"
            f = NEW ID3MCDI(fbody, ME, h)
          CASE "PCNT"
            f = NEW ID3PCNT(fbody, ME, h)
          CASE "POPM"
            f = NEW ID3POPM(fbody, ME, h)
          CASE "PRIV"
            f = NEW ID3PRIV(fbody, ME, h)
          CASE "UFID"
            f = NEW ID3UFID(fbody, ME, h)
          'CASE "USLT"
          '  f = NEW ID3USLT(fbody, ME, h)
        END SELECT 
      END IF
    END IF
    
    IF NOT IsNull(f) THEN result.Add(f, h.id)
    body = Mid(body, 1 + h.size + h.frameSize)
    
    IF $header.tagSize - h.tStart - h.frameSize = 0 THEN ' tag-size reached
      IF $header.useFooter AND Left(body, 3) = "3DI" THEN BREAK ' start footer
    ELSE IF $header.tagSize - h.tStart - h.frameSize <= 0 THEN 
      BREAK 
    END IF
  LOOP UNTIL Asc(body) = 0 ' start padding
  RETURN result
  
END

PUBLIC SUB AddFrame(id AS String, ID3Frame AS Object)
  IF Len(id) <> 4 THEN RETURN 
  IF NOT $frames.Exist(id) THEN $frames.Add(ID3Frame, id)
END

STATIC PUBLIC FUNCTION DeSynchsafe(s AS String) AS Long

  DIM result AS Long
  DIM x AS Integer
  DIM y AS Byte
  DIM z AS Integer = 0
  
  FOR x = Len(s) TO 1 STEP -1
    y = CByte(Asc(s, x))
    IF BTst(y, 7) THEN RETURN -1 
    DO
      IF BTst(y, z MOD 7) THEN result = BSet(result, z)
      INC z
    LOOP UNTIL (z MOD 7) = 0
  NEXT 
  RETURN result
  
END

STATIC PUBLIC FUNCTION Synchsafe(i AS Integer, OPTIONAL length AS Integer = 0) AS String
  
  DIM result AS String
  DIM c AS Integer
  DIM x AS Integer
  DIM tmp AS Byte
  DIM akt AS String
  
  IF length = 0 THEN length = Round((Len(Bin(i)) - 1) \ 7) ' byte-count
  'result = String(length, Chr(0))
  
  FOR x = 1 TO length * 8
    IF x MOD 8 = 0 THEN 
      result = Chr(tmp) & result
      tmp = 0
      CONTINUE 
    END IF
    akt = Mid(Bin(i), Len(Bin(i)) - c, 1)
    IF Val(akt) THEN tmp = BSet(tmp, c)
    INC c
  NEXT 
  RETURN result
  
END

PUBLIC FUNCTION render() AS String
  
  DIM useFooter AS Boolean = Settings["ID3v2_UseFooter"]
  DIM usePadding AS Boolean = Settings["ID3v2_UsePadding"]
  
END

PUBLIC FUNCTION getNone(which AS String) AS Variant
  
  SELECT CASE which
    CASE "track"
      RETURN trackNone
    CASE ELSE  
      RETURN ""
  END SELECT 
  
END


PRIVATE FUNCTION artist_Read() AS String[]
  IF IsNull(ME["TPE1"]) THEN RETURN NULL
  IF ME["TPE1"].content.Count = 0 THEN RETURN NULL
  RETURN ME["TPE1"].content
END
PRIVATE SUB artist_Write(Value AS String[])
END
PRIVATE FUNCTION album_Read() AS String[]
  IF IsNull(ME["TALB"]) THEN RETURN NULL
  IF ME["TALB"].content.Count = 0 THEN RETURN NULL
  RETURN ME["TALB"].content
END
PRIVATE SUB album_Write(Value AS String[])
END
PRIVATE FUNCTION track_Read() AS String[]
  IF IsNull(ME["TRCK"]) THEN RETURN NULL
  IF ME["TRCK"].content.Count = 0 THEN RETURN NULL
  RETURN ME["TRCK"].content
END
PRIVATE SUB track_Write(Value AS String[])
END
PRIVATE FUNCTION year_Read() AS String[]
  IF IsNull(ME["TYER"]) THEN RETURN NULL
  IF ME["TYER"].content.Count = 0 THEN RETURN NULL
  RETURN ME["TYER"].content
END
PRIVATE SUB year_Write(Value AS String[])
END
PRIVATE FUNCTION genre_Read() AS String[]
  IF IsNull(ME["TCON"]) THEN RETURN NULL
  IF ME["TCON"].content.Count = 0 THEN RETURN NULL
  RETURN ME["TCON"].content
END
PRIVATE SUB genre_Write(Value AS String[])
END
PRIVATE FUNCTION title_Read() AS String[]
  IF IsNull(ME["TIT2"]) THEN RETURN NULL
  IF ME["TIT2"].content.Count = 0 THEN RETURN NULL
  RETURN ME["TIT2"].content
END
PRIVATE SUB title_Write(Value AS String[])
END
PRIVATE FUNCTION isEmpty_Read() AS Boolean
  IF Len(ME.album) > 0 THEN RETURN FALSE
  IF Len(ME.artist) > 0 THEN RETURN FALSE
  IF Len(ME.comment) > 0 THEN RETURN FALSE
  IF Len(ME.genre) > 0 THEN RETURN FALSE
  IF Len(ME.title) > 0 THEN RETURN FALSE
  IF ME.track >= 0 THEN RETURN FALSE
  IF ME.year > 0 THEN RETURN FALSE
  RETURN TRUE
END 
PRIVATE FUNCTION comment_Read() AS String
  RETURN ""
END
PRIVATE SUB comment_Write(Value AS String)
END
PRIVATE FUNCTION version_Read() AS Float
  RETURN Val($version)
END
PRIVATE SUB version_Write(Value AS Float)
  $version = Str(Value)
END
PRIVATE FUNCTION changed_Read() AS Boolean
  RETURN $changed
END
PRIVATE FUNCTION header_Read() AS CTagv2Header
  RETURN $header
END
PRIVATE FUNCTION extHeader_Read() AS CTagv2ExtHeader
  RETURN $extHeader
END
PRIVATE FUNCTION statusOK_Read() AS Boolean
  RETURN $status
END
PRIVATE FUNCTION parent_Read() AS CTag
  RETURN $parent
END
