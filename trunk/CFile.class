' Gambas class file

PUBLIC CONST TYPE_UNKNOWN AS Integer = -1
PUBLIC CONST TYPE_MP3 AS Integer = 0
PUBLIC CONST TYPE_OGG AS Integer = 1

PROPERTY READ path AS String ' contains the filename including full path on hdd
PROPERTY newpath AS String ' if not set differently, contains the same as path, will be applied on save
PROPERTY tag AS CTag ' contains all (supported) tags of the specified file
PROPERTY READ changed AS Boolean ' returns whether anything on this file was changed (not yet saved)
PROPERTY READ header AS CMPEGHeader ' contains some informations from MPEG-header(s to come)
PROPERTY READ fileType AS Integer ' returns what type the music file is of

PRIVATE $tag AS CTag
PRIVATE $path AS String
PRIVATE $changed AS Boolean
PRIVATE $newpath AS String
PRIVATE $header AS CMPEGHeader
PRIVATE $filetype AS Integer = TYPE_UNKNOWN

' reading all "knowable" information: tags and headers
PUBLIC SUB _new(OPTIONAL filepath AS String = "")
  
  DIM t AS CMPEGHeader
  
  IF NOT Exist(filepath) THEN RETURN 
  $path = filepath
  $newpath = filepath
  IF String.LCase(File.Ext(filepath)) = "mp3" THEN $filetype = TYPE_MP3
  IF String.LCase(File.Ext(filepath)) = "ogg" OR String.LCase(File.Ext(filepath)) = "flac" THEN $filetype = TYPE_OGG
  $tag = NEW CTag(ME, filepath)
  $header = getFileHeader(filepath)
  
END

' this function is needed in every class which shall be mergable
' it is used by MHelp.merge() to determine the "None"-value for each item, because this might differ
PUBLIC FUNCTION getNone(which AS String) AS Variant
  
  SELECT CASE which
    CASE "tag"
      RETURN NULL
    CASE "path"
      RETURN ""
    CASE "changed"
      RETURN TRUE
    CASE "header"
      RETURN NULL
    CASE "newpath"
      RETURN ""
  END SELECT 
  
END

PUBLIC SUB save(OPTIONAL tagversion AS Integer = 0)
  
  DIM tmp AS String
  DIM f AS File
  
  SELECT CASE ME.fileType
    CASE CFile.TYPE_MP3
      IF $tag.needsRewrite THEN 
        tmp = Temp()
        f = OPEN tmp FOR WRITE 
        IF NOT $tag.v2.isEmpty THEN writev2Tag(f)
        appendAudio(f)
        IF NOT $tag.v1.isEmpty THEN writev1Tag(f)
        CLOSE #f
        KILL $path
        MOVE tmp TO $path
      ELSE 
        IF NOT $tag.v2.isEmpty THEN writev2Tag()
        IF NOT $tag.v1.isEmpty THEN writev1Tag()
      END IF
      
    CASE CFile.TYPE_OGG
      
    CASE CFile.TYPE_UNKNOWN
      ' FIXME: what to do if filetype could not be discovered?
  END SELECT 
  
END

PRIVATE SUB appendAudio(file AS File)
  
  DIM f AS File
  DIM pf AS Object[] = $tag.positionsInFile
  DIM x AS Integer
  DIM pos AS Long = 0
  DIM tmp AS String
  
  f = OPEN $path FOR READ 
  FOR x = 0 TO pf.Max
    IF pf[x][0] < pf[x][1] AND pf[x][0] > 0 THEN 
      SEEK #f, pos
      READ #f, tmp, pf[x][0] - pos
      WRITE #file, tmp
    END IF
    IF pf[x][1] > 0 THEN pos = pf[x][1] + 1
  NEXT 
  CLOSE #f
  
END

PRIVATE SUB writev2Tag(OPTIONAL file AS File = NULL)
  
  DIM f AS File
  
  SELECT CASE IsNull(file)
    CASE TRUE ' overwrites tag in _this_ file
      f = OPEN $path FOR WRITE 
      WRITE #f, $tag.v2.render()
      CLOSE #f
      
    CASE FALSE ' writes tag to the beginning of the file-argument
      SEEK #file, 0
      WRITE #file, $tag.v2.render()
      
  END SELECT 
  
END

PUBLIC SUB writev1Tag(OPTIONAL file AS File = NULL)
  
  DIM f AS File
  
  SELECT CASE IsNull(file)
    CASE TRUE
      f = OPEN $path FOR WRITE
      SEEK #f, If($tag.v1.exists, 0, -128)
      WRITE #f, $tag.v1.render()
      CLOSE #f
      
    CASE FALSE
      WRITE #file, $tag.v1.render()
      
  END SELECT 
  
END

PUBLIC FUNCTION getBytesFromFile(start AS Integer, size AS Integer) AS String
  
  DIM f AS File
  DIM s AS String
  
  f = OPEN $path FOR INPUT 
  SEEK #f, start
  READ #f, s, size
  CLOSE #f
  RETURN s
  
END


' returns the first MPEG-header in file
STATIC PUBLIC FUNCTION getFileHeader(path AS String) AS CMPEGHeader
  
  DIM x AS Integer
  DIM t AS String
  DIM u AS String
  DIM v AS String
  DIM f AS File
  DIM result AS CMPEGHeader
  
  IF NOT Exist(path) THEN RETURN result
  
  f = OPEN path FOR INPUT  
  
  WHILE NOT Eof(f)
    READ #f, t, 1
    bla:
    IF t = Chr(255) THEN 
      READ #f, u, 1
      IF (Asc(u) AND &HE0) = &HE0 THEN 
        READ #f, v, 2
        result = NEW CMPEGHeader(t & u & v)
        RETURN result 
      ELSE IF u = Chr(255) THEN 
        t = u
        GOTO bla
      END IF
    END IF
  WEND 
  
  CLOSE #f
  result = NEW CMPEGHeader
  RETURN result
  
END

' trims subsequential zero-bytes away
STATIC PUBLIC FUNCTION trimzero(v AS String) AS String
  RETURN Left(v, InStr(v, Chr(0)) - 1)
END

PRIVATE FUNCTION path_Read() AS String
  RETURN $path
END
PRIVATE FUNCTION Tag_Read() AS CTag
  RETURN $tag
END
PRIVATE SUB Tag_Write(Value AS CTag)
  $tag = Value
  $changed = TRUE
END
PRIVATE FUNCTION changed_Read() AS Boolean
  RETURN $changed OR $tag.changed
END
PRIVATE FUNCTION newpath_Read() AS String
  RETURN $newpath
END
PRIVATE SUB newpath_Write(Value AS String)
  $newpath = Value
  $changed = TRUE
END
PRIVATE FUNCTION header_Read() AS CMPEGHeader
  RETURN $header
END
PRIVATE FUNCTION fileType_Read() AS Integer
  RETURN $filetype
END
